include c.snippets

# file header
snippet headerh
	//
	//  ${1:`Filename()`}.h
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	 
	${0}
snippet headers
	//
	//  ${1:`Filename()`}.m
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	 
	${0}
# template for header
snippet objch
	//
	//  ${1:`Filename()`}.h
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	@interface $1 : NSObject
	@end${0}
snippet vch
	//
	//  ${1:`Filename()`}.h
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	@interface $1 : UIViewController
	@end${0}
snippet singleton for interface
	//
	//  ${1:`Filename()`}.h
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	#import "ILSingleton.h"
	
	@interface $1 : NSObject
	
	/**
	 * + ($1*)sharedInstance;
	 * + (void)releaseSharedInstance;
	 */
	INTERFACE_FOR_SINGLETON($1)
		${0}
	@end
# template for source
snippet objcs
	//
	//  ${1:`Filename()`}.m
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	#import "$1.h"
	
	@implementation $1
		${0}
	@end
snippet vcs
	//
	//  ${1:`Filename()`}.m
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	#import "$1.h"
	
	@implementation $1
	
	//----------------------------------------------------------------------------//
	#pragma mark - View lifecycle
	//----------------------------------------------------------------------------//
	
	- (void)viewDidLoad
	{
		[super viewDidLoad];
	}
		${0}
	@end
snippet singleton for implemention
	//
	//  ${1:`Filename()`}.m
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	#import "$1.h"
	
	@implementation $1
	IMPLEMENTATION_FOR_SINGLETON($1)
		${0}
	@end
snippet enum
	typedef NS_ENUM(NSUInteger, ${1:Type}) {
		${2:TypeNone} = 0,
		${3:TypeDone},
	};
# template for TestCase
snippet testcase
	//
	//  ${1:`Filename()`}.m
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	#import <XCTest/XCTest.h>
	#import "${2:Subject}.h"
	
	@interface $1 : XCTestCase
	@property (strong) $2* subject;
	@end 
	
	@implementation $1
	
	- (void)setUp
	{
		[super setUp];
		self.subject = [$2 new];
	}
	
	- (void)tearDown
	{
		[super tearDown];
	}
	
	- (void)testExample
	{
		XCTFail(@"No implementation for \"%s\"", __PRETTY_FUNCTION__);
	}
	
	@end
# template for CKDTestCase
snippet ckdtestcase
	//
	//  ${1:`Filename()`}.m
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	#import "CKDTestCase.h"
	#import "${2:Subject}.h"
	
	#define subject (($2*)self.subject)
	
	@interface $1 : CKDTestCase
	@end 

	@implementation $1
	
	- (void)setUp
	{
		[super setUp];
		[self setSubject:[$2 new]];
	}
	
	- (void)tearDown
	{
		[super tearDown];
	}
	
	- (void)testExample
	{
		expect(0).to.equal(1);
	}
	
	@end
snippet SELF
	__weak ${1:id} ${2:SELF} = ${3:self};
snippet ghassertnoerr
	GHAssertNoErr(${1:a1}, ${2:nil})
snippet ghasserterr
	GHAssertErr(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertnotnull
	GHAssertNotNULL(${1:a1}, ${2:nil})
snippet ghassertnull
	GHAssertNULL(${1:a1}, ${2:nil})
snippet ghassertnotequals
	GHAssertNotEquals(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertnotequalobjects
	GHAssertNotEqualObjects(${1:a1}, ${2:a2}, ${3:desc})
snippet ghassertoperation
	GHAssertOperation(${1:a1}, ${2:a2}, ${3:op}, ${4:nil})
snippet ghassertgreaterthan
	GHAssertGreaterThan(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertgreaterthanorequal
	GHAssertGreaterThanOrEqual(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertlessthan
	GHAssertLessThan(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertlessthanorequal
	GHAssertLessThanOrEqual(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertequalstrings
	GHAssertEqualStrings(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertnotequalstrings
	GHAssertNotEqualStrings(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertequalcstrings
	GHAssertEqualCStrings(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertnotequalcstrings
	GHAssertNotEqualCStrings(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertequalobjects
	GHAssertEqualObjects(${1:a1}, ${2:a2}, ${3:nil})
snippet ghassertequals
	GHAssertEquals(${1:a1}, ${2:a2}, ${3:nil})
snippet ghabsolutedifference
	GHAbsoluteDifference(left,right) (MAX(left,right)-MIN(left,right))
snippet ghassertequalswithaccuracy
	GHAssertEqualsWithAccuracy(${1:a1}, ${2:a2}, ${3:accuracy}, ${3:nil})
snippet ghfail
	GHFail(${1:nil})
snippet ghassertnil
	GHAssertNil(${1:a1}, ${2:nil})
snippet ghassertnotnil
	GHAssertNotNil(${1:a1}, ${2:nil})
snippet ghasserttrue
	GHAssertTrue(${1:expr}, ${2:nil})
snippet ghasserttruenothrow
	GHAssertTrueNoThrow(${1:expr}, ${2:nil})
snippet ghassertfalse
	GHAssertFalse(${1:expr}, ${2:nil})
snippet ghassertfalsenothrow
	GHAssertFalseNoThrow(${1:expr}, ${2:nil})
snippet ghassertthrows
	GHAssertThrows(${1:expr}, ${2:nil})
snippet ghassertthrowsspecific
	GHAssertThrowsSpecific(${1:expr}, ${2:specificException}, ${3:nil})
snippet ghassertthrowsspecificnamed
	GHAssertThrowsSpecificNamed(${1:expr}, ${2:specificException}, ${3:aName}, ${4:nil})
snippet ghassertnothrow
	GHAssertNoThrow(${1:expr}, ${2:nil})
snippet ghassertnothrowspecific
	GHAssertNoThrowSpecific(${1:expr}, ${2:specificException}, ${3:nil})
snippet ghassertnothrowspecificnamed
	GHAssertNoThrowSpecificNamed(${1:expr}, ${2:specificException}, ${3:aName}, ${4:nil})
# template for instance variables
snippet im
	${1:id} ${2:varName}_;
# template for a method call
snippet mc
	[${1:instance} ${2:method}];
# input a string literal
snippet @
	@"${1:literal}"${2}
# use a method
snippet [
	[${1:instance} ${2:method}]${3}
snippet [[
	[[${1:instance} ${2:method1}] ${3:method2}]${4}
# define a instance method 
snippet -(
	- (${1:void})${2:methodName};${3}
snippet -((
	- (${1:void})${2:methodName}:(${3:argType})${4:argName};${5}
# define a class method 
snippet +(
	+ (${1:void})${2:methodName};${3}
snippet +((
	+ (${1:void})${2:methodName}:(${3:argType})${4:argName};${5}
# define a action method 
snippet action
	- (IBAction)${1:action}${2::(id)sender}
	{
		${0}
	}
# override a init 
snippet -init
	- (instancetype)init
	{
		if ((self = [super init])) {
			${1}
		}
		return self;
	}
# add  a initWithXXX method 
snippet -initw
	- (instancetype)initWith${1:X}:(${2:argType}):${3:argName};${4}
# override a dealloc
snippet -dealloc
	- (void)dealloc
	{
		${1}
		[super dealloc];
	}
# template for alloc&init
snippet new
	[${1:className} new]${2}
snippet autorelease
	[[[${1:className} alloc] init] autorelesae]${2}
snippet rel
	self.${1:varName} = nil;${2}
# define a protocol
snippet @protocol
	//----------------------------------------------------------------------------//
	#pragma mark - $1
	//----------------------------------------------------------------------------//

	@protocol ${1:protocolName}
	${2:@required}
	${3:@optional}
	@end 
# define a protocol for delegate
snippet @delegate
	//----------------------------------------------------------------------------//
	#pragma mark - $1
	//----------------------------------------------------------------------------//
	
	@protocol ${1:`Filename()`Delegate}
	@required
	@optional
	@end 
# define a interface
snippet @interface
	//----------------------------------------------------------------------------//
	#pragma mark - $1
	//----------------------------------------------------------------------------//
	
	@interface ${1:`Filename()`} : NSObject
	@end 
# define a private category
snippet @private
	@interface ${1:`Filename()`} ()
	@end 
# define a category
snippet @category
	//----------------------------------------------------------------------------//
	#pragma mark - Category $2
	//----------------------------------------------------------------------------//

	@interface ${1:`Filename()`} (${2:categoryName})
	@end 

	@implementation $1 ($2)
	@end
snippet #pm
	//----------------------------------------------------------------------------//
	#pragma mark - ${1:`Filename()`}
	//----------------------------------------------------------------------------//
snippet #pmme
	//----------------------------------------------------------------------------//
	#pragma mark - Memory Management
	//----------------------------------------------------------------------------//
snippet #pmpm
	//----------------------------------------------------------------------------//
	#pragma mark - Private Methods
	//----------------------------------------------------------------------------//
snippet #pmpu
	//----------------------------------------------------------------------------//
	#pragma mark - Public Interface
	//----------------------------------------------------------------------------//
snippet #pmli
	//----------------------------------------------------------------------------//
	#pragma mark - Lifecycle
	//----------------------------------------------------------------------------//
snippet #pmpr
	//----------------------------------------------------------------------------//
	#pragma mark - ${1:Protocol} Methods
	//----------------------------------------------------------------------------//
snippet #pmom
	//----------------------------------------------------------------------------//
	#pragma mark - Override Methods
	//----------------------------------------------------------------------------//
snippet #pmre
	//----------------------------------------------------------------------------//
	#pragma mark - Responder
	//----------------------------------------------------------------------------//
# insert a implementation
snippet @impl
	@implementation ${1:`Filename()`}
	@end 
# import a header
snippet #i
	#import "${1:fileName}.h"${2}
# use a selector
snippet @sel
	@selector(${1:method})${2}
# define a property
snippet iboutlet
	@property (weak) IBOutlet ${1:id} ${2:varName};${3}
snippet ib
	@property (weak) IBOutlet ${1:id} ${2:varName};${3}
snippet @prop
	@property (${1:strong}) ${2:id} ${3:varName};${4}
# define a NSString property
snippet @propc
	@property (${1:copy}) ${2:NSString} ${3:*varName};${4}
# define a delegate property
snippet @propa
	@property (${1:assign}) ${2:NSUInteger} ${3:count};${4}
snippet @propw
	@property (${1:weak}) ${2:id} ${3:delegate};${4}
# prop snippets 
snippet @p strong
	@property (${1:strong}) ${2:id} ${3:varName};${4}
snippet @p copy
	@property (${1:copy}) ${2:id} ${3:varName};${4}
snippet @p weak
	@property (${1:weak}) ${2:id} ${3:varName};${4}
snippet @p assign
	@property (${1:assign}) ${2:NSUInteger} ${3:varName};${4}
# template for synthesize
snippet @s
	@synthesize ${1:varName} = $1_${2:;}
# use respondsToSelector
snippet responds
	if ([${1:(id)delegate_} respondsToSelector:@selector(${2:SEL})]) {
		[$1 $2];
	}
# use conformsToProtocol
snippet conforms
	if ([${1:(id)delegate_} conformsToProtocol:@protocol(${2:protocol})]) {
		[$1 ${3:prefix:self} ${4:method:arg}];
	}
# use isKindOf
snippet kindof
	if ([${1:sender} isKindOfClass:[${2:UIView} class]]) {
		$2* ${3:obj} = $1;
	} 
# forreach
snippet forr
	for (${1:id} ${2:object} in ${3:array}) {
	}
# NSLog
snippet log
	NSLog(@"${1}"${2:#:,});${0}
# NSAssert
snippet assert
	NSAssert(${1}, @"${2}");
snippet assertnil
	NSAssert(${1:sender}, @"$1 is nil");
snippet assertequal
	NSAssert(${1:lhs} == ${2:rhs}, @"$1 isn't $2");
snippet assertkind
	NSAssert([${1:sender} isKindOfClass:[${2:NSString} class]], @"$1 isn't $2");
# UIView
snippet add
	[${1:self.view} addSubview:${2:subview}];
# UIImageView
snippet image
	UIImage *image = [UIImage imageNamed:${1:@"xxx.png"}];
	UIImageView *${2:imageView} = [[UIImageView alloc] initWithImage:image];
	// $2_ = [[UIImageView alloc] initWithImage:image];
# autoresizingMask
snippet maskwh
	${1:view}.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
snippet maskmargin
	${1:view}.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin |
															 UIViewAutoresizingFlexibleRightMargin |
															 UIViewAutoresizingFlexibleTopMargin |
															 UIViewAutoresizingFlexibleBottomMargin;
snippet maskall
	${1:view}.autoresizingMask = UIViewAutoresizingFlexibleWidth |
															 UIViewAutoresizingFlexibleHeight |
															 UIViewAutoresizingFlexibleLeftMargin |
															 UIViewAutoresizingFlexibleRightMargin |
															 UIViewAutoresizingFlexibleTopMargin |
															 UIViewAutoresizingFlexibleBottomMargin;
# UIAlert
snippet alert
	UIAlertView *alert = [UIAlertView new];
	alert.message = ${1:message};
	// alert.cancelButtonIndex = 0;
	// [alert addButtonWithTitle:@"${2:Cancel}"];
	[alert addButtonWithTitle:@"${2:OK}"];
	[alert show];
# bundle
snippet path
	NSBundle *mainBundle = [NSBundle mainBundle];
	if (path = [mainBundle pathForResource:@"${1:sample}" ofType:@"${2:txt}"]) {
		NSData *data = [NSData dataWithContentsOfFile:path];
	}
# viewcontroller
snippet viewWillAppear
	- (void)viewWillAppear:(BOOL)animated
	{
		[super viewWillAppear:animated];
	}
snippet viewDidAppear
	- (void)viewDidAppear:(BOOL)animated
	{
		[super viewDidAppear:animated];
	}
snippet viewWillDisappear
	- (void)viewWillDisappear:(BOOL)animated
	{
		[super viewWillDisappear:animated];
	}
snippet viewDidDisappear
	- (void)viewDidDisappear:(BOOL)animated 
	{
		[super viewDidDisappear:animated];
	}
# button
snippet button
	UIButton *${1:button} = [UIButton buttonWithType:${2:UIButtonTypeRoundedRect}];
	[$1 setTitle:@"${3:BUTTON}" forState:UIControlStateNormal];
	[$1 sizeToFit];
# barButton
snippet barbutton
	UIBarButtonItem *${1:barButton} =
		[[UIBarButtonItem alloc] initWithBarButtonSystemItem:${2:UIBarButtonSystemItemAction}
		// [[UIBarButtonItem alloc] initWithTitle:@"BUTTON"
		//                                  style:UIBarButtonItemStyleBordered
		                                              target:self
		                                              action:@selector(${3:barButtonDidPush})];
# UIControl
snippet addtarget
	[${1:button} addTarget:${2:self}
	                action:@selector(${3:buttonDidPush})
	      forControlEvents:${4:UIControlEventTouchUpInside}];
# UIActionSheet
snippet actionsheet
	UIActionSheet *sheet = [UIActionSheet new];
	sheet.delegate = self;
	[sheet addButtonWithTitle:@"action1"];
	[sheet addButtonWithTitle:@"action2"];
	[sheet addButtonWithTitle:@"Cancel"];
	sheet.cancelButtonIndex = 2;
	[sheet showInView:self.view];
	// [sheet showFromToolbar:self.navigationController.toolbar];

	- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex
	{
		if (buttonIndex == actionSheet.cancelButtonIndex) {
			NSLog(@"pushed Cancel button.");
		}
	}
# UIResponder
snippet touches
	- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
	{
		// [self.nextResponder touchesBegan:touches withEvent:event];
	}
	- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
	{
		// [self.nextResponder touchesEnded:touches withEvent:event];
	}
	- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
	{
		// [self.nextResponder touchesMoved:touches withEvent:event];
	}
	- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
	{
		// [self.nextResponder touchesCancelled:touches withEvent:event];
	}
# UIView
snippet animation
	[UIView beginAnimations:nil context:NULL];
	[UIView setAnimationDuration:0.5];
	// view.alpha = 1.0;
	[UIView commitAnimations];
# blocks
snippet ^
	^${1:}{
		${3}
	}${2:];}
snippet nettask
	[ILNet get:${1:urlString}
		finished:^(NSData *data){
			${2:UIImage *image = [[UIImage alloc] initWithData:data];}
		}
		failed:^(NSError *error){
			NSLog([error localizedDescription]);
		}
		cancelled:^{
			NSLog(@"cancelled");
		}
		finally:^{
			NSLog(@"finally...");
		}
	];
snippet task
	${1:ILTask}* ${2:task} = [[$1 alloc] init];
	[ILTaskManager startTask:$2
		finished:^{
			NSLogLine();
		}
		failed:^(NSError *error){
			NSLogLine();
			NSLog(@"%@", error);
		}
		cancelled:^{
		}
		finally:^{
		}
	];
# dispatch once 
snippet once
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		${1}
	});
snippet main_queue
	dispatch_async(dispatch_get_main_queue(), ^{
		${1}
	});
snippet global_queue
	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
		${1}
	});
snippet pool
	@autoreleasepool {
		${1}
	}
#gestures
snippet gesture swipe
	UISwipeGestureRecognizer *swipeLeftGesture =
		[[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipeLeftGesture:)];
	swipeLeftGesture.direction = UISwipeGestureRecognizerDirectionLeft;
	[${1:self.view} addGestureRecognizer:swipeLeftGesture];
	UISwipeGestureRecognizer *swipeRightGesture =
		[[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipeRightGesture:)];
	swipeRightGesture.direction = UISwipeGestureRecognizerDirectionRight;
	[$1 addGestureRecognizer:swipeRightGesture];
	
	- (void)swipeLeftGesture:(id)sender
	{
		NSLog(@"#left");
	}
	- (void)swipeRightGesture:(id)sender
	{
		NSLog(@"#right");
	}
# UITableView
snippet table ios5
	//----------------------------------------------------------------------------//
	#pragma mark - UITableViewDataSource
	//----------------------------------------------------------------------------//
	
	- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
	{
		return 1;
	}
	
	- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
	{
		static NSString *const kTableViewCellIdentifier = @"UITableViewCell";
		UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:kTableViewCellIdentifier];
		if (nil == cell) {
			cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:kTableViewCellIdentifier];
		}
		return cell;
	}
	
	//----------------------------------------------------------------------------//
	#pragma mark - UITableViewDelegate
	//----------------------------------------------------------------------------//
	
	- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
	{
	}
snippet table ios6
	//----------------------------------------------------------------------------//
	#pragma mark - UITableViewDataSource
	//----------------------------------------------------------------------------//
	
	- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
	{
		return 1;
	}
	
	- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
	{
		static NSString *const kTableViewCellIdentifier = @"UITableViewCell";
		UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:kTableViewCellIdentifier forIndexPath:indexPath];
		return cell;
	}
	
	//----------------------------------------------------------------------------//
	#pragma mark - UITableViewDelegate
	//----------------------------------------------------------------------------//
	
	- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
	{
	}
snippet notification
	[[NSNotificationCenter defaultCenter] postNotificationName:${1:name} object:${2:nil}];${0}
snippet observer
	[[NSNotificationCenter defaultCenter] addObserver:self
		selector:@selector(${1:_xxxNotification:})
		name:${2:name}
		object:${3:nil}];
snippet lstr
	NSLocalizedString(@"${1:KEY}", nil)${0}
# expecta
snippet expect equal
	expect(${1:subject}).${2:to}.equal(${3:expect});${0}
snippet expect beIdenticalTo
	expect(${1:subject}).${2:to}.beIdenticalTo(${3:expect});${0}
snippet expect beNil
	expect(${1:subject}).${2:to}.beNil();${0}
snippet expect beTruthy
	expect(${1:subject}).${2:to}.beTruthy();${0}
snippet expect beFalsy
	expect(${1:subject}).${2:to}.beFalsy();${0}
snippet expect contain
	expect(${1:subject}).${2:to}.contain(${3:expect});${0}
snippet expect haveCountOf
	expect(${1:subject}).${2:to}.haveCountOf(${3:expect});${0}
snippet expect beEmpty
	expect(${1:subject}).${2:to}.beEmpty();${0}
snippet expect beInstanceOf
	expect(${1:subject}).${2:to}.beInstanceOf([${3:expect} class]);${0}
snippet expect beKindOf
	expect(${1:subject}).${2:to}.beKindOf([${3:expect} class]);${0}
snippet expect beSubclassOf
	expect([${1:subject} class]).${2:to}.beSubclassOf([${3:expect} class]);${0}
snippet expect beInTheRangeOf
	expect(${1:subject}).${2:to}.beInTheRangeOf(${3:from}, ${4:to});${0}
snippet expect beCloseTo
	expect(${1:subject}).${2:to}.beCloseTo(${3:expect});${0}
snippet expect beCloseToWithin
	expect(${1:subject}).${2:to}.beCloseToWithin(${3:from}, ${4:to});${0}
snippet expect raise
	expect(^{${1:/* code */}}).${2:to}.raise(@"${3:ExceptionName}");${0}
snippet expect raiseAny
	expect(^{${1:/* code */}}).${2:to}.raiseAny();${0}
snippet main
	#!/usr/bin/env objc-run
	
	@import Foundation;
	
	//----------------------------------------------------------------------------//
	#pragma mark - interface
	//----------------------------------------------------------------------------//
	
	@interface Sample : NSObject
	
	- (NSString *)say;
	
	@end 
	
	//----------------------------------------------------------------------------//
	#pragma mark - implementation
	//----------------------------------------------------------------------------//
	
	@implementation Sample
	
	- (NSString *)say
	{
	    return @"hello!";
	}
	
	@end
	
	//----------------------------------------------------------------------------//
	#pragma mark - main
	//----------------------------------------------------------------------------//
	
	int main(int argc, const char *argv[])
	{
	    Sample *sample = [Sample new];
	    NSLog(@"say: %@", [sample say]);
	    return 0;
	}
snippet stringf
	[NSString stringWithFormat:@"${1:%@}", ${2:x}]${0}
snippet awakeFromNib
	- (void)awakeFromNib
	{
	    [super awakeFromNib];
	    
	    ${0}
	}
snippet wself
	__weak typeof(self) wself = self;
