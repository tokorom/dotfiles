snippet template_header
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
snippet header
	template_header
snippet template_shell
	 #!/usr/bin/env xcrun swift
	 // vim: ft=swift
	
	 ${0}
snippet template_class
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	final class $1 {${0}
	}
snippet template_view
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import UIKit
	
	final class $1: ${2:UIView} {${0}
	}
snippet template_viewcontroller
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import UIKit
	
	final class $1: ${2:UIViewController} {${0}
	}
snippet template_tableviewcontroller
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import UIKit
	
	final class $1: ${2:UITableViewController} {${0}
	}
	
	// MARK: - UITableViewDataSource
	
	extension ${1:`expand('%:t:r')`} {
		override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			return 1
		}
	
		override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath)
			return cell
		}
	}
	
	// MARK: - UITableViewDelegate
	
	extension ${1:`expand('%:t:r')`} {
		override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
		}
	}
snippet template_struct
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	struct $1 {${0}
	}
snippet template_enum
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	enum $1 {${0}
	}
snippet template_identiable
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import Foundation
	
	struct $1: Identifiable {
		let id: ${2:String}${0}
	}
snippet template_protocol
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	protocol $1 {${0}
	}
snippet template_extension
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	extension $1 {${0}
	}
snippet protocol
	// MARK: - ${1:`expand('%:t:r')`}
	
	protocol $1 {${0}
	}
snippet ext
	extension
snippet extension
	// MARK: - ${1:Extension}
	
	extension ${2:`expand('%:t:r')`: }$1 {${0}
	}
snippet enum
	enum ${1:Name}${2} {
		case ${3:Label}
	}
snippet import
	import ${1:UIKit}
snippet i
	import
snippet let
	let ${1:name} = ${2:val}
snippet var
	var ${1:name} = ${2:value}
snippet vv
	var ${1:name}: ${2:Type} = ${3:value}
snippet weak
	weak var ${1:name}: ${2:type}?
snippet struct
	struct ${1:name} {
		var ${2:\#:variant = 0}
	}
snippet init
	init(${1:\#:parameters}) {
		${0}
	}
snippet convenience_init
	convenience init(${1:\#:parameters}) {
		${0}
	}
snippet conini
	convenience_init
snippet deinit
	deinit {
		${0}
	}
snippet init_coder
	init?(coder: NSCoder, value: Value) {
		self.value = value
		
		super.init(coder: coder)
	}
	
	required init?(coder: NSCoder) {
		fatalError("Invalid init")
	}
snippet segueaction_init
	init_coder
snippet func
	func ${1:something}(${2:\#:parameters}) ${3:\#:-> Int }{
		${0}
	}
snippet override
	override func ${1:something}(${2:\#:parameters}) ${3:\#:-> Int }{
		${0}
	}
snippet {
	{ (${1:\#:parameters}) -> ${2:\#:return type} in
		${0}
	}
snippet if
	if ${1:true} {
		${0}
	}
snippet if_let
	if let ${1:let} = ${2:true} {
		${0}
	}
snippet if_case
	if case let (${1:_}, ${2:value as Int}) = ${3:dicts} {
		${0}
	}
snippet guard_let
	guard let ${1:name} = ${2:name} else {
		return ${3:nil}
	}
	${0}
snippet guard_case
	guard case let (${1:_}, ${2:value as Int}) = ${3:dicts} else {
		return
	}
snippet for
	for ${1:_} in ${2:\#:list} {
		${0}
	}
snippet for_index
	for ${1:index} in 0..<${2:count} {
		${0}
	}
snippet for_each
	for index in ${1:elements}.indices {
		let ${2:element} = $1[index]
		${0}
	}
snippet for_case
	for case let ${1:value} as ${2:Type} in ${3:values} {
		${0}
	}
snippet while
	while ${1:true} {
		${0}
	}
snippet switch
	switch ${1:val} {
	case ${2:definition}:
		${0}
	default:
	}
snippet where
	switch ${1:tupple} {
	case let ${2:(x, y)} where ${3:x == y}:
		${0}
	}
snippet alert
	let alert = UIAlertView()
	alert.message = "hello"
	alert.addButtonWithTitle("OK")
	alert.show()
snippet #pm
	// MARK: - ${1:`expand('%:t:r')`}
snippet #pmpm
	// MARK: - Private Methods
snippet #pmpu
	// MARK: - Public Interface
snippet #pmli
	// MARK: - Lifecycle
snippet #pmac
	// MARK: - Actions
snippet #pmpr
	// MARK: - Properties
snippet log
	NSLog("${1}")
snippet print
	print("${1}")
snippet \
	\(${1})${0}
snippet ibaction
	@IBAction func ${1:action}(sender: ${2:AnyObject}) {
		${0}
	}
snippet IBOutlet
	@IBOutlet private weak var ${1:label}: ${2:UILabel}?
snippet iboutlet
	IBOutlet
snippet ib
	IBOutlet
snippet lazy
	lazy var ${1:string} = ${2}
snippet ibinspectable
	@IBInspectable
snippet ibdesignable
	@IBDesignable
snippet lstr
	NSLocalizedString("${1:key}", comment: "${2}")
snippet viewDidLoad
	override func viewDidLoad() {
		super.viewDidLoad()
	
		${0}
	}
snippet viewWillAppear
	override func viewWillAppear(_ animated: Bool) {
		super.viewWillAppear(animated)
	
		${0}
	}
snippet viewDidAppear
	override func viewDidAppear(_ animated: Bool) {
		super.viewDidAppear(animated)
	
		${0}
	}
snippet viewWillDisappear
	override func viewWillDisappear(_ animated: Bool) {
		super.viewWillDisappear(animated)
	
		${0}
	}
snippet viewDidDisappear
	override func viewDidDisappear(_ animated: Bool) {
		super.viewDidDisappear(animated)
	
		${0}
	}
snippet willMove
	override func willMove(toParent parent: UIViewController?) {
		super.willMove(toParent: parent)
	
		${0}
	}
snippet didMove
	override func didMove(toParent parent: UIViewController?) {
		super.didMove(toParent: parent)
	
		${0}
	}
snippet viewWillLayoutSubviews
	override func viewWillLayoutSubviews() {
		super.viewWillLayoutSubviews()
	
		${0}
	}
snippet viewDidLayoutSubviews
	override func viewDidLayoutSubviews() {
		super.viewDidLayoutSubviews()
	
		${0}
	}
snippet prepareForSegue
	override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
		if let destination = segue.findDestination(as: ${1:ModelAcceptable}.self) {
			destination.${2:accept(model)}$0
		}
	}
snippet UITableViewDelegate
	// MARK: - UITableViewDelegate
	
	extension ${1:`expand('%:t:r')`}: UITableViewDelegate {
		func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
		}
	}
snippet UITableViewDataSource
	// MARK: - UITableViewDataSource
	
	extension ${1:`expand('%:t:r')`}: UITableViewDataSource {
		func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
		}
	
		func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
		}
	}
snippet dequeueReusableCell
	let cell = tableView.dequeueReusableCell(withIdentifier: "${1:FooCell}", for: indexPath)
	${2:// cell.textLabel?.text = "bar"}${0}
	return cell
snippet numberOfSectionsInTableView
	func numberOfSections(in tableView: UITableView) -> Int {
		${0}
	}
snippet titleForHeaderInSection
	func tableView(tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
		${0}
	}
snippet UITableViewDelegate_viewForHeaderInSection
	func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -> UIView {
		${0}
	}
snippet UITableViewDelegate_heightForHeaderInSection
	func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
		${0}
	}
snippet UITableViewDelegate_heightForRowAtIndexPath
	func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
		return ${1: UITableViewAutomaticDimension}
	}
snippet UITableViewDelegate_estimatedHeightForRowAtIndexPath
	func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
		return ${1: UITableViewAutomaticDimension}
	}
snippet UITableViewDelegate_willDisplayForRowAt
	func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
		${0}
	}
snippet UICollectionViewDataSource
	// MARK: - UICollectionViewDataSource
	
	extension ${1:`expand('%:t:r')`}: UICollectionViewDataSource {
		func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
			return 1
		}
	
		func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
			let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
			return cell
		}
	}
snippet UICollectionViewDelegate
	// MARK: - UICollectionViewDelegate
	
	extension ${1:`expand('%:t:r')`}: UICollectionViewDelegate {
		func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
		}
	}
snippet dispatch_after
	DispatchQueue.main.asyncAfter(deadline: .now() + ${1:5}) {
		${0}
	}
snippet dispatch_async_global
	DispatchQueue.global().async {
		${0}
	}
snippet global_queue
	dispatch_async_global
snippet dispatch_async_main
	DispatchQueue.main.async {
		${0}
	}
snippet main_queue
	dispatch_async_main
snippet awakeFromNib
	override func awakeFromNib() {
		super.awakeFromNib()
		
		${0}
	}
snippet layoutSubviews
	override func layoutSubviews() {
		super.layoutSubviews()
		
		${0}
	}
snippet sharedInstance
	static let shared = ${1:`expand('%:t:r')`}()${0}
	private init() {}
snippet defaultInstance
	static let \`default\` = ${1:`expand('%:t:r')`}()${0}
snippet promise_function
	func ${1:requestXXX}() -> Promise<${2:Int}> {
		let promise = Promise<$2>({ fulfiller, rejecter in
			self.client.GET("/partners/today").then { (res: APIResponse) -> Void in
				fulfiller(0)
			}.catch { (error: NSError) -> Void in
				rejecter(error)
			}.finally {
			}
			return
		})
		return promise
	}
snippet unwind_segue
	@IBAction func ${1:unwindToHere}(segue: UIStoryboardSegue) {
		${0}
	}
snippet segueaction
	IBSegueAction
snippet IBSegueAction
	@IBSegueAction func create${1:ViewController}(_ coder: NSCoder, sender: Any?, segueIdentifier: String?) -> UIViewController? {
		return $1(coder: coder)
	}
snippet segueaction_selector
	create:sender:segueIdentifier:
snippet animateWithDuration
	UIView.animate(withDuration: 0.25) { () in
		${0}
	}
snippet animateWithDuration_with_completion
	UIView.animate(withDuration: 0.25, delay: 0.0, options: .curveEaseInOut, animations: { () in
		${0}
	}, completion: { (stopped: Bool) in
		if (stopped) {
		}
	})
snippet animateWithSpring
	UIView.animate(
		withDuration: 0.25,
		delay: 0.0,
		usingSpringWithDamping: 0.5,
		initialSpringVelocity: 0.0,
		options: .curveEaseInOut,
		animations: { () in
			${0}
		}, completion: { (stopped: Bool) in
			if (stopped) {
			}
		}
	)
snippet available_if
	if #available(${1:iOS 12.0}, *) {
		${0}
	}
snippet available_guard
	guard #available(${1:iOS 12.0}, *) else {
		${2:return}
	}
snippet available_annotation
	@available(${1:iOS 12.0}, *)${0}
snippet subscript_int
	subscript(index: Int) -> ${1:Int} {
		get {
			${0}
		}
		set {
		}
	}
snippet subscript_any
	subscript(index: ${1:String}) -> ${2:Any} {
		get {
			${0}
		}
		set {
		}
	}
snippet notimplemented
	fatalError("\(#function) is not implemented")
snippet assertionFailure
	assertionFailure("${1:Invalid condition}")${0}
snippet assert
	XCTAssert(${1})${0}
snippet assertequal
	XCTAssertEqual(${1}, ${2})${0}
snippet assertequalwithaccuracy
	XCTAssertEqualWithAccuracy(${1}, ${2})${0}
snippet assertfalse
	XCTAssertFalse(${1})${0}
snippet assertgreaterthan
	XCTAssertGreaterThan(${1}, ${2})${0}
snippet assertgreaterthanorequal
	XCTAssertGreaterThanOrEqual(${1}, ${2})${0}
snippet assertlessthan
	XCTAssertLessThan(${1}, ${2})${0}
snippet assertlessthanorequal
	XCTAssertLessThanOrEqual(${1}, ${2})${0}
snippet assertnil
	XCTAssertNil(${1})${0}
snippet assertnotequal
	XCTAssertNotEqual(${1}, ${2})${0}
snippet assertnotequalwithaccuracy
	XCTAssertNotEqualWithAccuracy(${1}, ${2})${0}
snippet assertnotnil
	XCTAssertNotNil(${1})${0}
snippet asserthrowserror
	XCTAssertThrowsError(${1})${0}
snippet asserttrue
	XCTAssertTrue(${1})${0}
snippet assertfail
	XCTFail(${1})${0}
snippet wself
	[weak self] in${0}
snippet arraySafeSubscriptIf
	if let ${2:value} = ${1:array}.indices.contains(${3:index}) ? $1[$3] : nil {
		${0}
	}
snippet arraySafeSubscriptGuard
	guard let ${2:value} = ${1:array}.indices.contains(${3:index}) ? $1[$3] : nil else {
		${0}
	}
snippet actionSheet
	let alert = UIAlertController(title: "${1}", message: "${2}", preferredStyle: .actionSheet)
	alert.addAction(UIAlertAction(title: "Action", style: .default) { [weak self] _ in
		${0}
	})
	alert.addAction(UIAlertAction(title: "キャンセル", style: .cancel))
	present(alert, animated: true)
snippet CustomDebugStringConvertible
	extension ${1:Target}: CustomDebugStringConvertible {
		var debugDescription: String {
			${0}
		}
	}
snippet debugstring
	CustomDebugStringConvertible
snippet #if_ios
	#if os(iOS)
	#else
	#endif
snippet if_ios
	#if_ios
snippet #if_os
	#if os(${1:iOS})
	#else
	#endif
snippet if_os
	#if_os
snippet test
	func test${1:Subject}() throws {
		${0}
	}
snippet template_swiftui_view
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import SwiftUI
	
	struct $1: View {
		private let ${2:value}: ${3:Value}
		
		init($2: $3) {
			self.$2 = $2
		}
		
		var body: some View {
			Text("Hello")${0}
		}
	}
	
	// MARK: - Previews
	
	struct $1_Previews: PreviewProvider {
		static var previews: some View {
			Group {
				$1()
			}
		}
	}
snippet UIViewRepresentable
	struct ${1:View}: UIViewRepresentable {
		func makeUIView(context: Context) -> ${2:UIView} {
			return $2()${0}
		}
		
		func updateUIView(_ UIView: $2, context: Context) {
		}
	}
snippet UIViewControllerRepresentable
	struct ${1:View}: UIViewControllerRepresentable {
		func makeUIViewController(context: Context) -> ${2:UIViewController} {
			return $2()${0}
		}
		
		func updateUIViewController(_ uiViewController: $2, context: Context) {
		}
	}
snippet UICollectionViewController_DiffeableDataSource
	final class ${1:Item}ListCollectionViewController: UICollectionViewController {
		typealias DataSource = UICollectionViewDiffableDataSource<Int, $1>
		typealias Snapshot = NSDiffableDataSourceSnapshot<Int, $1>
		
		private lazy var dataSource: DataSource = createDataSource()
		private lazy var snapshot: Snapshot = Snapshot()
		
		private var lastLayoutViewSize: CGSize?
		
		override func viewDidLoad() {
			super.viewDidLoad()
			
			collectionView.dataSource = dataSource
			
			bind()
			
			invalidateLayout(animated: true)
		}
		
		override func viewDidLayoutSubviews() {
			super.viewDidLayoutSubviews()
			
			invalidateLayout(animated: true)
		}
		
		private func bind() {
			// applyDataSource(${2:item}s)
		}
		
		private func applyDataSource(_ $2s: [$1]) {
			snapshot.deleteAllItems()
			
			snapshot.appendSections([0])
			snapshot.appendItems($2s, toSection: 0)
			
			dataSource.apply(snapshot, animatingDifferences: true)
		}
	}
	
	// MARK: - UICollectionViewDataSource
	
	extension $1ListCollectionViewController {
		private func createDataSource() -> DataSource {
			let dataSource = DataSource(collectionView: collectionView) { collectionView, indexPath, $2 in
				let cellIdentifier: String = "$1"
				let cell = collectionView.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath)
				// cell.find($1Adoptable.self)?.adopt$1($2)
				return cell
			}
			return dataSource
		}
		
		private func $2(at indexPath: IndexPath) -> $1? {
			let section = indexPath.section
			guard section < snapshot.numberOfSections else {
				return nil
			}
				
			let item = indexPath.item
			guard item < snapshot.numberOfItems(inSection: section) else {
				return nil
			}
			
			return snapshot.itemIdentifiers(inSection: section)[item]
		}
	}
	
	// MARK: - Layout
	
	extension $1ListCollectionViewController {
		private func invalidateLayout(animated: Bool) {
			guard lastLayoutViewSize != collectionView.bounds.size else {
				return
			}
			
			collectionView.setCollectionViewLayout(createLayout(for: collectionView), animated: animated)
		}
		
		private func createLayout(for collectionView: UICollectionView) -> UICollectionViewLayout {
			let viewSize = collectionView.bounds.size
			
			self.lastLayoutViewSize = viewSize
			
			let itemHeight: CGFloat = 70
			let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0), heightDimension: .absolute(itemHeight))
			let item = NSCollectionLayoutItem(layoutSize: itemSize)
			let group = NSCollectionLayoutGroup.horizontal(layoutSize: itemSize, subitems: [item])
			let section = NSCollectionLayoutSection(group: group)
			
			return UICollectionViewCompositionalLayout(section: section)
		}
	}
	
	// MARK: - UICollectionViewDelegate
	
	extension $1ListCollectionViewController {
		override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
			guard let $2 = self.$2(at: indexPath) else {
				return
			}
		}
	}
snippet Equatable
	// MARK: - Equatable
	
	extension ${1:`expand('%:t:r')`}: Equatable {
		static func == (lhs: Self, rhs: Self) -> Bool {
			return lhs.id == rhs.id
		}
	}
snippet Hashable
	// MARK: - Hashable
	
	extension ${1:`expand('%:t:r')`}: Hashable {
		func hash(into hasher: inout Hasher) {
			hasher.combine(self.foo)
			hasher.combine(self.bar)
		}
	}
snippet CocoaAction
	CocoaAction.send(from: self) { (handler: ${1:FooHandler}) in
		handler.${2:handleFoo}(${3:foo})
	}
snippet Combine
	import Combine
		private var cancellables: Set<AnyCancellable> = []
		private func bind() {
			SampleState.shared.currentValueSubject
				.receive(on: DispatchQueue.main)
				.sink { [weak self] in
					self?.handleSample($0)
				}
				.store(in: &cancellables)
		}
		private func handleSample(_ sample: Sample) {
		}
snippet withCheckedContinuation
	await withCheckedContinuation { continuation in
		doSomething { foo in
			continuation.resume(returning: foo)
		}
	}
snippet withCheckedThrowingContinuation
	try await withCheckedThrowingContinuation { continuation in
		doSomething { result in
			continuation.resume(with: result)
		}
	}
snippet withCheckedThrowingContinuationWithoutResult
	try await withCheckedThrowingContinuation { continuation in
		doSomething { foo in
			try {
				let bar = try something()
				continuation.resume(returning: bar)
			} catch {
				continuation.resume(throwing: error)
			}
		}
	}
snippet TERMINATE
	{TERMINATE}
