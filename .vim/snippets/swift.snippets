snippet template_header
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
snippet header
	template_header
snippet template_shell
	 #!/usr/bin/env xcrun swift
	 // vim: ft=swift
	
	 ${0}
snippet template_class
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	final class $1 {${0}
	}
snippet template_class_view
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import UIKit
	
	final class $1: ${2:UIView} {${0}
	}
snippet template_class_viewcontroller
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import UIKit
	
	final class $1: ${2:UIViewController} {${0}
	}
snippet template_struct
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	struct $1 {${0}
	}
snippet template_protocol
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	protocol $1 {${0}
	}
snippet template_extension
	//
	//  ${1:`expand('%:t:r')`}.swift
	//
	//  Created by ToKoRo on `strftime("%Y-%m-%d")`.
	//
	
	import ${2:Foundation}
	
	extension $1 {${0}
	}
snippet protocol
	// MARK: - ${1:`expand('%:t:r')`}
	
	protocol $1 {${0}
	}
snippet ext
	extension
snippet extension
	// MARK: - ${1:Extension}
	
	extension ${2:`expand('%:t:r')`: }$1 {${0}
	}
snippet enum
	enum ${1:Name}${2} {
		case ${3:Label}
	}
snippet import
	import ${1:UIKit}
snippet i
	import
snippet let
	let ${1:name} = ${2:val}
snippet var
	var ${1:name} = ${2:value}
snippet vv
	var ${1:name}: ${2:Type} = ${3:value}
snippet weak
	weak var ${1:name}: ${2:type}?
snippet struct
	struct ${1:name} {
		var ${2:\#:variant = 0}
	}
snippet init
	init(${1:\#:parameters}) {
		${0}
	}
snippet convenience_init
	convenience init(${1:\#:parameters}) {
		${0}
	}
snippet conini
	convenience_init
snippet deinit
	deinit {
		${0}
	}
snippet func
	func ${1:something}(${2:\#:parameters}) ${3:\#:-> Int }{
		${0}
	}
snippet override
	override func ${1:something}(${2:\#:parameters}) ${3:\#:-> Int }{
		${0}
	}
snippet {
	{ (${1:\#:parameters}) -> ${2:\#:return type} in
		${0}
	}
snippet if
	if ${1:true} {
		${0}
	}
snippet if_let
	if let ${1:let} = ${2:true} {
		${0}
	}
snippet if_case
	if case let (${1:_}, ${2:value as Int}) = ${3:dicts} {
		${0}
	}
snippet guard_let
	guard let ${1:name} = ${2:name} else {
		return ${3:nil}
	}
	${0}
snippet guard_case
	guard case let (${1:_}, ${2:value as Int}) = ${3:dicts} else {
		return
	}
snippet for
	for ${1:_} in ${2:\#:list} {
		${0}
	}
snippet for_index
	for ${1:index} in 0..<${2:count} {
		${0}
	}
snippet for_each
	for index in ${1:elements}.indices {
		let ${2:element} = $1[index]
		${0}
	}
snippet for_case
	for case let ${1:value} as ${2:Type} in ${3:values} {
		${0}
	}
snippet while
	while ${1:true} {
		${0}
	}
snippet switch
	switch ${1:val} {
	case ${2:definition}:
		${0}
	default:
	}
snippet where
	switch ${1:tupple} {
	case let ${2:(x, y)} where ${3:x == y}:
		${0}
	}
snippet alert
	let alert = UIAlertView()
	alert.message = "hello"
	alert.addButtonWithTitle("OK")
	alert.show()
snippet #pm
	// MARK: - ${1:`expand('%:t:r')`}
snippet #pmpm
	// MARK: - Private Methods
snippet #pmpu
	// MARK: - Public Interface
snippet #pmli
	// MARK: - Lifecycle
snippet #pmac
	// MARK: - Actions
snippet #pmpr
	// MARK: - Properties
snippet log
	NSLog("${1}")
snippet print
	print("${1}")
snippet \
	\(${1})${0}
snippet ibaction
	@IBAction func ${1:action}(sender: ${2:AnyObject}) {
		${0}
	}
snippet IBOutlet
	@IBOutlet weak var ${1:label}: ${2:UILabel}?
snippet iboutlet
	IBOutlet
snippet ib
	IBOutlet
snippet lazy
	lazy var ${1:string} = ${2}
snippet ibinspectable
	@IBInspectable
snippet ibdesignable
	@IBDesignable
snippet lstr
	NSLocalizedString("${1:key}", comment: "${2}")
snippet viewDidLoad
	override func viewDidLoad() {
		super.viewDidLoad()
	
		${0}
	}
snippet viewWillAppear
	override func viewWillAppear(_ animated: Bool) {
		super.viewWillAppear(animated)
	
		${0}
	}
snippet viewDidAppear
	override func viewDidAppear(_ animated: Bool) {
		super.viewDidAppear(animated)
	
		${0}
	}
snippet viewWillDisappear
	override func viewWillDisappear(_ animated: Bool) {
		super.viewWillDisappear(animated)
	
		${0}
	}
snippet viewDidDisappear
	override func viewDidDisappear(_ animated: Bool) {
		super.viewDidDisappear(animated)
	
		${0}
	}
snippet willMove
	override func willMove(toParent parent: UIViewController?) {
		super.willMove(toParent: parent)
	
		${0}
	}
snippet didMove
	override func didMove(toParent parent: UIViewController?) {
		super.didMove(toParent: parent)
	
		${0}
	}
snippet viewWillLayoutSubviews
	override func viewWillLayoutSubviews() {
		super.viewWillLayoutSubviews()
	
		${0}
	}
snippet viewDidLayoutSubviews
	override func viewDidLayoutSubviews() {
		super.viewDidLayoutSubviews()
	
		${0}
	}
snippet prepareForSegue
	override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
		if let destination = segue.findDestination(as: ${1:ModelAcceptable}.self) {
			destination.${2:accept(model)}$0
		}
	}
snippet UITableViewDelegate
	// MARK: - UITableViewDelegate
	
	extension ${1:`expand('%:t:r')`}: UITableViewDelegate {
		func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
		}
	}
snippet UITableViewDataSource
	// MARK: - UITableViewDataSource
	
	extension ${1:`expand('%:t:r')`}: UITableViewDataSource {
		func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
		}
	
		func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
		}
	}
snippet dequeueReusableCell
	let cell = tableView.dequeueReusableCell(withIdentifier: "${1:FooCell}", for: indexPath)
	${2:// cell.textLabel?.text = "bar"}${0}
	return cell
snippet numberOfSectionsInTableView
	func numberOfSections(in tableView: UITableView) -> Int {
		${0}
	}
snippet titleForHeaderInSection
	func tableView(tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
		${0}
	}
snippet UITableViewDelegate_viewForHeaderInSection
	func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -> UIView {
		${0}
	}
snippet UITableViewDelegate_heightForHeaderInSection
	func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
		${0}
	}
snippet UITableViewDelegate_heightForRowAtIndexPath
	func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
		return ${1: UITableViewAutomaticDimension}
	}
snippet UITableViewDelegate_estimatedHeightForRowAtIndexPath
	func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
		return ${1: UITableViewAutomaticDimension}
	}
snippet UICollectionViewDataSource
	// MARK: - UICollectionViewDataSource
	
	extension ${1:`expand('%:t:r')`}: UICollectionViewDataSource {
		func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
			return 1
		}
	
		func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
			let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
			return cell
		}
	}
snippet UICollectionViewDelegate
	// MARK: - UICollectionViewDelegate
	
	extension ${1:`expand('%:t:r')`}: UICollectionViewDelegate {
		func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
		}
	}
snippet dispatch_after
	DispatchQueue.main.asyncAfter(deadline: .now() + ${1:5}) {
		${0}
	}
snippet dispatch_async_global
	DispatchQueue.global().async {
		${0}
	}
snippet global_queue
	dispatch_async_global
snippet dispatch_async_main
	DispatchQueue.main.async {
		${0}
	}
snippet main_queue
	dispatch_async_main
snippet awakeFromNib
	override func awakeFromNib() {
		super.awakeFromNib()
		
		${0}
	}
snippet layoutSubviews
	override func layoutSubviews() {
		super.layoutSubviews()
		
		${0}
	}
snippet singleton
	static let shared = ${1:`expand('%:t:r')`}()${0}
snippet promise_function
	func ${1:requestXXX}() -> Promise<${2:Int}> {
		let promise = Promise<$2>({ fulfiller, rejecter in
			self.client.GET("/partners/today").then { (res: APIResponse) -> Void in
				fulfiller(0)
			}.catch { (error: NSError) -> Void in
				rejecter(error)
			}.finally {
			}
			return
		})
		return promise
	}
snippet unwind_segue
	@IBAction func ${1:unwindToHere}(segue: UIStoryboardSegue) {
		${0}
	}
snippet segueaction
	IBSegueAction
snippet IBSegueAction
	@IBSegueAction func create${1:ViewController}(_ coder: NSCoder, sender: Any?, segueIdentifier: String?) -> UIViewController? {
		return $1(coder: coder)
	}
snippet segueaction_selector
	create:sender:segueIdentifier:
snippet animateWithDuration
	UIView.animate(withDuration: 0.25) { () in
		${0}
	}
snippet animateWithDuration_with_completion
	UIView.animate(withDuration: 0.25, delay: 0.0, options: .curveEaseInOut, animations: { () in
		${0}
	}, completion: { (stopped: Bool) in
		if (stopped) {
		}
	})
snippet animateWithSpring
	UIView.animate(
		withDuration: 0.25,
		delay: 0.0,
		usingSpringWithDamping: 0.5,
		initialSpringVelocity: 0.0,
		options: .curveEaseInOut,
		animations: { () in
			${0}
		}, completion: { (stopped: Bool) in
			if (stopped) {
			}
		}
	)
snippet available_if
	if #available(${1:iOS 12.0}, *) {
		${0}
	}
snippet available_guard
	guard #available(${1:iOS 12.0}, *) else {
		${2:return}
	}
snippet available_annotation
	@available(${1:iOS 12.0}, *)${0}
snippet subscript_int
	subscript(index: Int) -> ${1:Int} {
		get {
			${0}
		}
		set {
		}
	}
snippet subscript_any
	subscript(index: ${1:String}) -> ${2:Any} {
		get {
			${0}
		}
		set {
		}
	}
snippet notimplemented
	fatalError("\(#function) is not implemented")
snippet assertionFailure
	assertionFailure("${1:Invalid condition}")${0}
snippet assert
	XCTAssert(${1})${0}
snippet assertequal
	XCTAssertEqual(${1}, ${2})${0}
snippet assertequalwithaccuracy
	XCTAssertEqualWithAccuracy(${1}, ${2})${0}
snippet assertfalse
	XCTAssertFalse(${1})${0}
snippet assertgreaterthan
	XCTAssertGreaterThan(${1}, ${2})${0}
snippet assertgreaterthanorequal
	XCTAssertGreaterThanOrEqual(${1}, ${2})${0}
snippet assertlessthan
	XCTAssertLessThan(${1}, ${2})${0}
snippet assertlessthanorequal
	XCTAssertLessThanOrEqual(${1}, ${2})${0}
snippet assertnil
	XCTAssertNil(${1})${0}
snippet assertnotequal
	XCTAssertNotEqual(${1}, ${2})${0}
snippet assertnotequalwithaccuracy
	XCTAssertNotEqualWithAccuracy(${1}, ${2})${0}
snippet assertnotnil
	XCTAssertNotNil(${1})${0}
snippet asserthrowserror
	XCTAssertThrowsError(${1})${0}
snippet asserttrue
	XCTAssertTrue(${1})${0}
snippet assertfail
	XCTFail(${1})${0}
snippet wself
	[weak self] in${0}
snippet arraySafeSubscriptIf
	if let ${2:value} = ${1:array}.indices.contains(${3:index}) ? $1[$3] : nil {
		${0}
	}
snippet arraySafeSubscriptGuard
	guard let ${2:value} = ${1:array}.indices.contains(${3:index}) ? $1[$3] : nil else {
		${0}
	}
snippet actionSheet
	let alert = UIAlertController(title: "${1}", message: "${2}", preferredStyle: .actionSheet)
	alert.addAction(UIAlertAction(title: "Action", style: .default) { [weak self] _ in
		${0}
	})
	alert.addAction(UIAlertAction(title: "キャンセル", style: .cancel))
	present(alert, animated: true)
snippet CustomDebugStringConvertible
	extension ${1:Target}: CustomDebugStringConvertible {
		var debugDescription: String {
			${0}
		}
	}
snippet debugstring
	CustomDebugStringConvertible
snippet #if_ios
	#if os(iOS)
	#else
	#endif
snippet if_ios
	#if_ios
snippet #if_os
	#if os(${1:iOS})
	#else
	#endif
snippet if_os
	#if_os
snippet test
	func test${1:Subject}() throws {
		${0}
	}
